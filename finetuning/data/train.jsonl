{"question":"Provide the documentation for the function according to task description.","answer":"Calculate the maximum value in each sliding window.\n\nArgs:\n    numbers: List of integers to process\n    window_size: Size of the sliding window\n\nReturns:\n    List of maximum values for each window position\n\nRaises:\n    ValueError: If window_size is invalid","context":"def sliding_window_max(numbers: list[int], window_size: int) -> list[int]:\n    if window_size <= 0 or window_size > len(numbers):\n        raise ValueError(\"Invalid window size\")\n    result = []\n    for i in range(len(numbers) - window_size + 1):\n        window = numbers[i:i + window_size]\n        result.append(max(window))\n    return result"}
{"question":"Provide the documentation for the function according to task description.","answer":"Execute multiple async tasks concurrently with a timeout.\n\nArgs:\n    tasks: List of coroutines to execute\n    timeout: Maximum time in seconds to wait for all tasks\n\nReturns:\n    List of results from all tasks\n\nRaises:\n    TimeoutError: If tasks do not complete within the timeout period","context":"import asyncio\nfrom typing import Coroutine, Any\n\nasync def gather_with_timeout(tasks: list[Coroutine], timeout: float) -> list[Any]:\n    try:\n        return await asyncio.wait_for(asyncio.gather(*tasks), timeout=timeout)\n    except asyncio.TimeoutError:\n        raise TimeoutError(f\"Tasks did not complete within {timeout} seconds\")"}
{"question":"Provide the documentation for the function according to task description.","answer":"Recursively merge two dictionaries, with override taking precedence.\n\nArgs:\n    base: The base dictionary\n    override: The dictionary whose values override the base\n\nReturns:\n    A new dictionary with deeply merged values","context":"import json\nfrom typing import Any\n\ndef deep_merge_dicts(base: dict[str, Any], override: dict[str, Any]) -> dict[str, Any]:\n    result = base.copy()\n    for key, value in override.items():\n        if key in result and isinstance(result[key], dict) and isinstance(value, dict):\n            result[key] = deep_merge_dicts(result[key], value)\n        else:\n            result[key] = value\n    return result"}
{"question":"Provide the documentation for the function according to task description.","answer":"Retry a function call with exponential backoff.\n\nArgs:\n    func: The callable to retry\n    max_attempts: Maximum number of retry attempts. Defaults to 3\n    delay: Delay in seconds between retries. Defaults to 1.0\n\nReturns:\n    The return value of the successful function call\n\nRaises:\n    Exception: Re-raises the last exception if all attempts fail","context":"def retry_operation(func, max_attempts: int = 3, delay: float = 1.0):\n    import time\n    from typing import Callable\n    \n    for attempt in range(max_attempts):\n        try:\n            return func()\n        except Exception as e:\n            if attempt == max_attempts - 1:\n                raise\n            time.sleep(delay)"}
{"question":"Provide the documentation for the function according to task description.","answer":"Ensure a directory exists, creating it if necessary.\n\nArgs:\n    directory_path: Path to the directory\n\nReturns:\n    True if directory was created, False if it already existed\n\nRaises:\n    ValueError: If path exists but is not a directory","context":"import os\n\ndef ensure_directory_exists(directory_path: str) -> bool:\n    if os.path.exists(directory_path):\n        if not os.path.isdir(directory_path):\n            raise ValueError(f\"Path exists but is not a directory: {directory_path}\")\n        return False\n    os.makedirs(directory_path, exist_ok=True)\n    return True"}
{"question":"Provide the documentation for the function according to task description.","answer":"Perform binary search on a sorted list.\n\nArgs:\n    sorted_list: A sorted list of comparable items\n    target: The item to search for\n\nReturns:\n    The index of the target if found, -1 otherwise","context":"from typing import Protocol\n\nclass Comparable(Protocol):\n    def __lt__(self, other) -> bool: ...\n\ndef binary_search(sorted_list: list[Comparable], target: Comparable) -> int:\n    left, right = 0, len(sorted_list) - 1\n    while left <= right:\n        mid = (left + right) \/\/ 2\n        if sorted_list[mid] == target:\n            return mid\n        elif sorted_list[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1"}
{"question":"Provide the documentation for the function according to task description.","answer":"Load configuration from a JSON file with default fallbacks.\n\nArgs:\n    config_file: Path to the configuration file\n    defaults: Dictionary of default configuration values\n\nReturns:\n    A dictionary with configuration values, using defaults for missing keys","context":"def load_config_with_defaults(config_file: str, defaults: dict[str, any]) -> dict[str, any]:\n    import json\n    try:\n        with open(config_file, 'r') as f:\n            config = json.load(f)\n    except FileNotFoundError:\n        config = {}\n    return {**defaults, **config}"}
{"question":"Provide the documentation for the function according to task description.","answer":"Check if a string is a palindrome.\n\nArgs:\n    text: The string to check\n    ignore_case: If True, comparison is case-insensitive. Defaults to True\n    ignore_spaces: If True, spaces are ignored. Defaults to True\n\nReturns:\n    True if the string is a palindrome, False otherwise","context":"def is_palindrome(text: str, ignore_case: bool = True, ignore_spaces: bool = True) -> bool:\n    processed = text\n    if ignore_case:\n        processed = processed.lower()\n    if ignore_spaces:\n        processed = processed.replace(' ', '')\n    return processed == processed[::-1]"}
{"question":"Provide the documentation for the function according to task description.","answer":"Partition a list into two lists based on a predicate function.\n\nArgs:\n    items: The list to partition\n    predicate: Function that returns True or False for each item\n\nReturns:\n    A tuple of two lists: (items where predicate is True, items where predicate is False)","context":"def partition_list(items: list[T], predicate: Callable[[T], bool]) -> tuple[list[T], list[T]]:\n    true_items = []\n    false_items = []\n    for item in items:\n        if predicate(item):\n            true_items.append(item)\n        else:\n            false_items.append(item)\n    return true_items, false_items"}
{"question":"Provide the documentation for the function according to task description.","answer":"Filter and return only even numbers from a list.\n\nArgs:\n    numbers: A list of integers to filter\n\nReturns:\n    A new list containing only the even integers from the input","context":"def filter_even_numbers(numbers: list[int]) -> list[int]:\n    return [n for n in numbers if n % 2 == 0]"}
{"question":"Provide the documentation for the function according to task description.","answer":"Fetch JSON data from an API endpoint.\n\nArgs:\n    url: The API endpoint URL\n    timeout: Request timeout in seconds. Defaults to 30\n    headers: Optional HTTP headers to include. Defaults to None\n\nReturns:\n    A dictionary containing the parsed JSON response\n\nRaises:\n    TimeoutError: If the request times out\n    ConnectionError: If the request fails for other reasons","context":"import requests\nfrom typing import Optional\n\ndef fetch_json_api(url: str, timeout: int = 30, headers: Optional[dict] = None) -> dict:\n    try:\n        response = requests.get(url, timeout=timeout, headers=headers or {})\n        response.raise_for_status()\n        return response.json()\n    except requests.exceptions.Timeout:\n        raise TimeoutError(f\"Request to {url} timed out after {timeout} seconds\")\n    except requests.exceptions.RequestException as e:\n        raise ConnectionError(f\"Failed to fetch data: {e}\")"}
{"question":"Provide the documentation for the function according to task description.","answer":"Merge two dictionaries with configurable overwrite behavior.\n\nArgs:\n    dict1: The base dictionary\n    dict2: The dictionary to merge into the base\n    overwrite: If True, values from dict2 overwrite dict1. If False, only add keys not in dict1. Defaults to True\n\nReturns:\n    A new dictionary containing the merged key-value pairs","context":"def merge_dictionaries(dict1: dict[str, any], dict2: dict[str, any], overwrite: bool = True) -> dict[str, any]:\n    result = dict1.copy()\n    if overwrite:\n        result.update(dict2)\n    else:\n        for key, value in dict2.items():\n            if key not in result:\n                result[key] = value\n    return result"}
{"question":"Provide the documentation for the function according to task description.","answer":"Create a memoization decorator for caching function results.\n\nArgs:\n    func: The function to memoize\n\nReturns:\n    A wrapped function that caches results based on arguments","context":"def memoize(func: Callable) -> Callable:\n    cache = {}\n    def wrapper(*args, **kwargs):\n        key = str(args) + str(kwargs)\n        if key not in cache:\n            cache[key] = func(*args, **kwargs)\n        return cache[key]\n    return wrapper"}
{"question":"Provide the documentation for the function according to task description.","answer":"Calculate the Euclidean distance between two 2D points.\n\nArgs:\n    point1: First point as (x, y) tuple\n    point2: Second point as (x, y) tuple\n\nReturns:\n    The Euclidean distance between the points","context":"def calculate_distance(point1: tuple[float, float], point2: tuple[float, float]) -> float:\n    import math\n    return math.sqrt((point2[0] - point1[0])**2 + (point2[1] - point1[1])**2)"}
{"question":"Provide the documentation for the function according to task description.","answer":"Rotate a list by a specified number of positions.\n\nArgs:\n    items: The sequence to rotate\n    positions: Number of positions to rotate (positive for right, negative for left)\n\nReturns:\n    A new list with elements rotated","context":"from typing import TypeVar, Sequence\n\nT = TypeVar('T')\n\ndef rotate_list(items: Sequence[T], positions: int) -> list[T]:\n    if not items:\n        return []\n    n = len(items)\n    positions = positions % n\n    return list(items[positions:]) + list(items[:positions])"}
{"question":"Provide the documentation for the function according to task description.","answer":"Perform division with a default value for division by zero.\n\nArgs:\n    numerator: The number to divide\n    denominator: The number to divide by\n    default: The value to return if denominator is zero. Defaults to 0.0\n\nReturns:\n    The result of the division, or the default value if denominator is zero","context":"def safe_divide(numerator: float, denominator: float, default: float = 0.0) -> float:\n    if denominator == 0:\n        return default\n    return numerator \/ denominator"}
{"question":"Provide the documentation for the function according to task description.","answer":"Build a URL query string from a dictionary of parameters.\n\nArgs:\n    params: Dictionary of query parameters (None values are excluded)\n\nReturns:\n    A URL-encoded query string","context":"from urllib.parse import urlencode\n\ndef build_query_string(params: dict[str, any]) -> str:\n    filtered_params = {k: v for k, v in params.items() if v is not None}\n    return urlencode(filtered_params)"}
{"question":"Provide the documentation for the function according to task description.","answer":"Write a list of dictionaries to a CSV file.\n\nArgs:\n    filepath: Path where the CSV file will be written\n    data: List of dictionaries to write as rows\n    fieldnames: List of field names for the CSV header","context":"import csv\n\ndef write_csv_file(filepath: str, data: list[dict[str, any]], fieldnames: list[str]) -> None:\n    with open(filepath, 'w', newline='', encoding='utf-8') as f:\n        writer = csv.DictWriter(f, fieldnames=fieldnames)\n        writer.writeheader()\n        writer.writerows(data)"}
{"question":"Provide the documentation for the function according to task description.","answer":"Group a list of dictionaries by a specified key.\n\nArgs:\n    items: List of dictionaries to group\n    key: The dictionary key to group by\n\nReturns:\n    A dictionary where keys are the unique values of the specified key, and values are lists of items with that key","context":"def group_by_key(items: list[dict], key: str) -> dict[any, list[dict]]:\n    result = {}\n    for item in items:\n        if key not in item:\n            continue\n        group_key = item[key]\n        if group_key not in result:\n            result[group_key] = []\n        result[group_key].append(item)\n    return result"}
{"question":"Provide the documentation for the function according to task description.","answer":"Clamp a value between minimum and maximum bounds.\n\nArgs:\n    value: The value to clamp\n    min_value: The minimum allowed value\n    max_value: The maximum allowed value\n\nReturns:\n    The clamped value\n\nRaises:\n    ValueError: If min_value is greater than max_value","context":"def clamp(value: float, min_value: float, max_value: float) -> float:\n    if min_value > max_value:\n        raise ValueError(\"min_value cannot be greater than max_value\")\n    return max(min_value, min(value, max_value))"}
{"question":"Provide the documentation for the function according to task description.","answer":"Validate user input data against required fields and email format.\n\nArgs:\n    data: Dictionary of user input data\n    required_fields: List of field names that must be present and non-empty\n    email_field: Optional field name to validate as email format. Defaults to None\n\nReturns:\n    A ValidationResult object containing validation status and any error messages","context":"from dataclasses import dataclass\nfrom typing import Optional\n\n@dataclass\nclass ValidationResult:\n    is_valid: bool\n    errors: list[str]\n    \ndef validate_user_input(data: dict[str, str], required_fields: list[str], \n                        email_field: Optional[str] = None) -> ValidationResult:\n    errors = []\n    for field in required_fields:\n        if field not in data or not data[field].strip():\n            errors.append(f\"Field '{field}' is required\")\n    \n    if email_field and email_field in data:\n        import re\n        if not re.match(r'^[^@]+@[^@]+\\.[^@]+$', data[email_field]):\n            errors.append(f\"Field '{email_field}' must be a valid email\")\n    \n    return ValidationResult(is_valid=len(errors) == 0, errors=errors)"}
{"question":"Provide the documentation for the function according to task description.","answer":"Calculate the median value of a list of numbers.\n\nArgs:\n    numbers: A list of numeric values\n\nReturns:\n    The median value as a float\n\nRaises:\n    ValueError: If the input list is empty","context":"def calculate_median(numbers: list[float]) -> float:\n    if not numbers:\n        raise ValueError(\"Cannot calculate median of empty list\")\n    sorted_nums = sorted(numbers)\n    n = len(sorted_nums)\n    mid = n \/\/ 2\n    if n % 2 == 0:\n        return (sorted_nums[mid - 1] + sorted_nums[mid]) \/ 2\n    return sorted_nums[mid]"}
{"question":"Provide the documentation for the function according to task description.","answer":"Find the key with the maximum value in a dictionary.\n\nArgs:\n    data: A dictionary with string keys and integer values\n\nReturns:\n    A tuple containing the key and its maximum value\n\nRaises:\n    ValueError: If the dictionary is empty","context":"def find_max_value(data: dict[str, int]) -> tuple[str, int]:\n    if not data:\n        raise ValueError(\"Cannot find max in empty dictionary\")\n    max_key = max(data, key=data.get)\n    return max_key, data[max_key]"}
{"question":"Provide the documentation for the function according to task description.","answer":"Find the n most common items in a list.\n\nArgs:\n    items: List of items to analyze\n    n: Number of most common items to return. Defaults to 1\n\nReturns:\n    List of tuples (item, count) for the n most common items\n\nRaises:\n    ValueError: If n is not positive","context":"from collections import Counter\n\ndef find_most_common(items: list[str], n: int = 1) -> list[tuple[str, int]]:\n    if n <= 0:\n        raise ValueError(\"n must be positive\")\n    counter = Counter(items)\n    return counter.most_common(n)"}
{"question":"Provide the documentation for the function according to task description.","answer":"Find the first item matching a regex pattern.\n\nArgs:\n    items: List of strings to search\n    pattern: Regular expression pattern to match\n\nReturns:\n    The first matching string, or None if no match found","context":"from typing import Optional\n\ndef find_first_match(items: list[str], pattern: str) -> Optional[str]:\n    import re\n    for item in items:\n        if re.search(pattern, item):\n            return item\n    return None"}
{"question":"Provide the documentation for the function according to task description.","answer":"Extract all numeric values from a text string.\n\nArgs:\n    text: The input string to extract numbers from\n\nReturns:\n    A list of floats found in the text","context":"def extract_numbers(text: str) -> list[float]:\n    import re\n    pattern = r'-?\\d+\\.?\\d*'\n    matches = re.findall(pattern, text)\n    return [float(m) for m in matches]"}
{"question":"Provide the documentation for the function according to task description.","answer":"Format a datetime as a human-readable relative time string.\n\nArgs:\n    dt: The datetime to format\n\nReturns:\n    A string like \"just now\", \"5 minutes ago\", \"2 hours ago\", or \"3 days ago\"","context":"from datetime import datetime, timedelta\n\ndef format_time_ago(dt: datetime) -> str:\n    now = datetime.now()\n    diff = now - dt\n    if diff < timedelta(minutes=1):\n        return \"just now\"\n    elif diff < timedelta(hours=1):\n        minutes = int(diff.total_seconds() \/ 60)\n        return f\"{minutes} minute{'s' if minutes != 1 else ''} ago\"\n    elif diff < timedelta(days=1):\n        hours = int(diff.total_seconds() \/ 3600)\n        return f\"{hours} hour{'s' if hours != 1 else ''} ago\"\n    else:\n        days = diff.days\n        return f\"{days} day{'s' if days != 1 else ''} ago\""}
{"question":"Provide the documentation for the function according to task description.","answer":"Generate the first n Fibonacci numbers.\n\nArgs:\n    n: Number of Fibonacci numbers to generate\n\nYields:\n    The next Fibonacci number in the sequence","context":"from typing import Generator\n\ndef fibonacci_generator(n: int) -> Generator[int, None, None]:\n    if n <= 0:\n        return\n    a, b = 0, 1\n    for _ in range(n):\n        yield a\n        a, b = b, a + b"}
